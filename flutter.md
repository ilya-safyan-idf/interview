<!-- TOC --><a name="flutter"></a>
# Flutter ...........................

<!-- TOC --><a name="-flutter-"></a>
### Устройство Flutter под капотом 
![image](https://user-images.githubusercontent.com/80569772/203052487-937d5923-9571-4752-9762-f0d6637b675e.png)

1. `Уровень фреймворка`
- всё, с чем мы работаем в момент написания приложения,
-  взаимодействует с `Flutter Engine` через слой абстракции, называемый `Window`

2. `Уровень движка` 
- виртуальная машина Dart более низкий уровень,
- `Skia` - графическая библиотека

3. `Уровень платформы`
- взаимодействия с операционной системой
- касания , жесты
- пауза приложения

`Flutter Engine` уведомляет `Flutter Framework`, когда:
- Событие, представляющее интерес, происходит на уровне устройства (изменение ориентации, изменение настроек, проблема с памятью, состояние работы приложения…)
- Какое-то событие происходит на уровне стекла (жест)
- Канал платформы отправляет некоторые данные
- Но также и в основном, когда Flutter Engine готов к рендерингу нового кадра
---
<!-- TOC --><a name="-flutter"></a>
### Модель выполнения во Flutter
1. Создание изолята (выполнения всего приложения)
2. Инит  Event Loop
3. запуск `main()`
4. запуск `Event Loop`
---

<!-- TOC --><a name="stateless-stateful-"></a>
## Stateless и Stateful виджеты
- `StatelessWidget`
 -- это виджет, который не имеет состояния
 -- в процессе работы приложения не изменяет своих свойств. 
 -- изменяется Они могут изменяться лишь посредством внешних событий, которые возникают в родительских виджетах 
- `StatefulWidget`
-- хранит состояние
-- состояние изменяется с помощью `setState()` 

```Dart
class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key, required this.title});

  final String title;

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {

  @override
  Widget build(BuildContext context) {
    return 
  }
}
```

---
<!-- TOC --><a name="-stateful-"></a>
## Жизненный цикл Stateful виджета

1.  `createState()` 

2.  `mounted is true`  
-- свойство  ***mounted*** в объекте State устанавливается в true. (означает что объект включен в дерево виджетов)
3.  `initState()` вызывается единожды при инициализации
4.  `didChangeDependencies()` 
-- вызывается единожды после инициализации
-- при уведомлениях от Inhherited-виджетов вверху по дереву
5.  `build()` 
-- вызывается каждый раз при перерисовке
6.  `didUpdateWidget(Widget oldWidget)` 
-- вызывается каждый раз когда перестраивается родительский виджет
7.  `setState()` вызывается императивно для перерисовки
8.  `deactivate()` вызывается, после перемещения Активного Элемента в список неактивного и при этому он удаляется из дерева.
9.  `dispose()` вызывается, когда этот объект удаляется из дерева **навсегда**
10.  `mounted is false`

--- 
<!-- TOC --><a name="buildcontext"></a>
### BuildContext
`BuildContext` - это интерфейс, который имплементирует `Element`. 

`BuildContext` может быть полезен, когда нужно:
- Получить ссылку на объект `RenderObject`,
- Получить размер `RenderObject`
- получить ближайший родительский `InheritedWidget`.
--  MediaQuery.of(context)
--  Theme.of(context)

---
<!-- TOC --><a name="inheritedwidget"></a>
### InheritedWidget
`InheritedWidget` —

-- взаимодействовать с данными которые лежат в инхерет виджете
--  это виджет, который предоставляет своим потомкам возможность взаимодействовать с данными, хранящимися в нём. Решает проблему с передачей данных через конструкторы. 

*Сложность у операции получения InheritedWidget - O(1). Такая скорость достигается за счёт того, что Inherited виджеты хранятся в виде хэш-таблицы в `Element`-е*

```Dart
class MyData extends InheritedWidget {
  final String data;

  MyData({
    Key? key,
    required this.data,
    required Widget child,
  }) : super(key: key, child: child);

  static MyData? of(BuildContext context) {
    return context.dependOnInheritedWidgetOfExactType<MyData>();
  }

  @override
  bool updateShouldNotify(MyData oldWidget) {
    return data != oldWidget.data;
  }
}


class MyWidget extends StatefulWidget {
  @override
  _MyWidgetState createState() => _MyWidgetState();
}

class _MyWidgetState extends State<MyWidget> {
  String _data = '';

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // Получаем доступ к данным через MyData
    final provider = MyData.of(context);
    if (provider != null) {
      _data = provider.data;
    }
  }

  @override
  Widget build(BuildContext context) {
  }
}
```

---
<!-- TOC --><a name="-4"></a>
### Деревья
![](https://docs.flutter.dev/assets/images/docs/arch-overview/trees.png)
- `Widget Tree` состоит из `Widget`, которые используются для описания пользовательского интерфейса
- `Element Tree` состоит из `Element`, которые управляют жизненым циклом виджета и связывают виджеты и объекты рендеринга.
- `Render Tree` состоит из `RenderObject`, которые используются для определения размеров, положения, геометрии, определения зон экрана, на которые могут повлиять жесты 
	
[Подробнее](https://habr.com/ru/company/surfstudio/blog/533210/)

---
<!-- TOC --><a name="widget"></a>
### Widget
`Widget` 
-- это иммутабельное описание части пользовательского интерфейса. 
-- знает что нужно делать

---
<!-- TOC --><a name="element"></a>
### Element
`Element` 
-- управляет жизненным цыклом 
-- реализует виджет в конвретном месте дерева

---
<!-- TOC --><a name="renderobject"></a>
### RenderObject
`RenderObject` 
-- это мутабельный класс 
-- отвечает за отображение

---
<!-- TOC --><a name="--7"></a>
### Виды виджетов
`Proxy` 
-- хранят информацию
-- не передают RenderObject 

- `InheritedWidget`
- `ParentDataWidget` (`LayoutId`, `Flexible`, `KeepAlive` и т.д.) 
- `NotificationListener`

`Component`
-- компнауют другие виджеты
-- не передают RenderObject
- `RaisedButton`
- `Scaffold`
- `Text`
- `GestureDetector`
- `Container`	

`Renderer` 
-- отвечают за отрисовку
-- передают RenderObject
- `Row`
- `Column`
- `Stack`
- `Padding`
- `Align`
- `Opacity`

---
<!-- TOC --><a name="-element-"></a>
### Как работает построение дерева
1.  flutter начинает работу
2. Flutter спрашивает у Widget, какой Elemtn нужен?
3. Создается элемент  и передает управление
4. Elemtn спрашивает у Widget какой RenderObject нужен ?
5. Создание RenderObject
6. Далее если у Widget есть Ребенок,
то Flutter спрашивает , а какой виджет нужен ему

---
<!-- TOC --><a name="-element-"></a>
### Как отрисоыввается виджет  Layout Flutter
1. во  Flutter Родитель устанавливает, позицию, и размер ребенка
2. constrains (огравничения) передаются вниз
3. а размеры Flutter передает вверх

Есть ограничения , а есть желания по размерам родительского виджета.
Если желаемы размеры не привышают ограничения, то все окей, если нет то будет ошибка


---
<!-- TOC --><a name="--8"></a>
### Виды элементов
![image](https://user-images.githubusercontent.com/80569772/205450564-87d6c2d0-a994-4d1d-bbaa-2c8f7fb07385.png)
1. `StatelessWidget`, `StatefulWidget`, `InheritedWidget` => **`ComponentElement`** 
-- компоновочный элемент,
-- не передает RenderObject (не отвечает за перерисовку)
-- который явно не содержит логику рисования/отображения. Есть метод `build()`, который возвращает виджет. Образуется только при создании виджетов .
- `StatelessElement`
- `StatefulElement`
- `ProxyElement`

2. `Columns` => **`MultiElement`** => RenderFlex
3. `Expanded` => **`ParentDataElement`**
4. `SizedBox` => **`SingleElement`** => RenderConstraiedBox

<!-- TOC --><a name="globalkeys"></a>
### GlobalKeys
`GlobalKeys` - это ключи, которые предоставляют доступ к виджетам. Для виджетов с отслеживанием состояния глобальные ключи также предоставляют доступ к состоянию. Позволяют виджетам менять родителей в любом месте приложения без потери состояния. Должны быть уникальны для всего приложения.

---
<!-- TOC --><a name="localkeys"></a>
### LocalKeys
`LocalKeys` - это ключи, которые нужны для идентификации виджетов в коллекции с одинаковыми значениеми должны быть уникальными среди виджетов с одним и тем же родительским виджетом. Могут использоваться для тестов:
- `ValueKey` - это ключ, который использует значение определенного типа для идентификации самого себя. Переопределяет оператор сравнения. Если value одниковое, то ключи одинаковые
- `UniqueKey` - это ключ, который равен только самому себе
- `ObjectKey` - это ключ, который используется для привязки идентификатора виджета к идентификатору объекта, используемого для создания этого виджета


<!-- TOC --><a name="custompaint"></a>
### CustomPaint
`CustomPaint` - это класс, который создает «холст» для рисования. В методе `paint` в качестве аргументов поступает `canvas`, который позволяет рисовать различные фигуры

---
<!-- TOC --><a name="widgetsflutterbinding"></a>
### WidgetsFlutterBinding
`WidgetsFlutterBinding` — конкретная реализация привязки приложений на основе инфраструктуры виджетов. По сути своей — это клей, соединяющий фреймворк и движок Flutter. `WidgetsFlutterBinding` состоит из множества связей: `GestureBinding`, `ServicesBinding`, `SchedulerBinding`, `PaintingBinding`, `SemanticsBinding`, `RendererBinding`, `WidgetsBinding`.

Метод `scheduleAttachRootWidget` является отложенной реализацией `attachRootWidget`. Принадлежит данный метод `WidgetsBinding`. В описании к нему сказано, что он присоединяет переданный виджет к `renderViewElement` — корневому элементу дерева элементов.

Метод `scheduleWarmUpFrame` принадлежит `SchedulerBinding` и используется для того, чтобы запланировать запуск кадра как можно скорее, не ожидая системного сигнала `Vsync`.

---
<!-- TOC --><a name="bindings"></a>
### Bindings
![image](https://user-images.githubusercontent.com/80569772/203303949-aadb037a-c818-4f63-8ad8-67c3812a96ad.png)

`Bindings` - это классы для обмена данными между `Flutter Framework` и `Flutter Engine`. Каждая привязка отвечает за обработку набора конкретных задач, действий, событий, сгруппированных по области деятельности.

`BaseBinding` — базовый абстрактный класс, давайте тогда рассмотрим конкретные реализации биндингов. Среди них мы увидим:  
  
`ServicesBinding` отвечает за перенаправление сообщений от текущей платформы в обработчик данных сообщений (`BinaryMessenger`);  
  
`PaintingBinding` отвечает за связь с библиотекой отрисовки.  
  
`RenderBinding` отвечает за связь между деревом рендеринга и движком Flutter.  
  
`WidgetBinding` отвечает за связь между деревом виджетов и движком Flutter.  
  
`SchedulerBinding` — планировщик очередных задач, таких как:  
- вызовы приходящих колбеков, которые инициирует система в `Window.onBeginFrame` — например события тикеров и контроллеров анимаций;
- вызовы непрерывных колбеков, которые инициирует система `Window.onDrawFrame`, например, события для обновления системы отображения после того, как отработают приходящие колбеки;
- посткадровые колбеки, которые вызываются после непрерывных колбеков, перед возвратом из `Window.onDrawFrame`;
- задачи не связанные с рендерингом, которые должны быть выполнены между кадрами.

`SemanticsBinding` отвечает за связь слоя семантики и движком Flutter.  
  
`GestureBinding` отвечает за работу с подсистемой жестов.

---
<!-- TOC --><a name="--9"></a>
### Каналы платформы

![image](https://user-images.githubusercontent.com/80569772/202891758-b7cc7db9-3b4c-4ce3-9f91-37f9a1a614a1.png)
**(!)** Платформенные взаимодействия возможны только в главном изоляте. Этот тот изолят, который создается при запуске вашего приложения. 

`Канал платформы` — это двусторонний канал связи между кодом на dart и нативом, который объединяет имя канала и кодек для кодирования сообщений в двоичную форму и обратно. Вызовы асинхронны. Каждый канал должен иметь уникальный идентификатор.  
	
`Каналы сообщений` - это каналы платформы, предназначенные для обмена сообщениями между нативным кодом и flutter-приложением.  
`Кодеки сообщений`:
- `BinaryCodec` Реализуя сопоставление идентификаторов в байтовых буферах, этот кодек позволяет вам наслаждаться удобством объектов канала в тех случаях, когда вам не требуется кодирование/декодирование. Каналы сообщений Dart с этим кодеком имеют тип BasicMessageChannel<ByteData>.
- `JSONMessageCodec` Работает с «JSON-подобными» значениями (строки, числа, логические значения, null, списки этих значений и мапы строка-ключ с этими данными). Списки и мапы неоднородны и могут быть вложены друг в друга. Во время кодирования значения преобразуются в строки JSON, а затем в байты с использованием UTF-8. Каналы сообщений Dart имеют тип BasicMessageChannel<dynamic> с этим кодеком.
- `StandardMessageCodec` Работает с несколько более обобщенными значениями, чем кодек JSON, поддерживая также однородные буферы данных (UInt8List, Int32List, Int64List, Float64List) и мапы с нестроковыми ключами. Обработка чисел отличается от JSON тем, что целые числа Dart поступают на платформу как 32- или 64-битные целые числа со знаком, в зависимости от величины никогда как числа с плавающей запятой. Значения кодируются в специальном, достаточно компактном и расширяемом двоичном формате. Стандартный кодек предназначен для выбора по умолчанию для канала связи во Flutter. Что касается JSON, каналы сообщений Dart, созданные с использованием стандартного кодека, имеют тип BasicMessageChannel<dynamic>.  
	
`Каналы методов` — это каналы платформы, предназначенные для вызова нативного кода из flutter-приложения.    
`Кодеки методов`:
- `StandardMethodCodec` делегирует кодирование значений полезной нагрузки (payload) в `StandardMessageCodec`. Поскольку последний является расширяемым, то же самое можно сказать и о первом.
- `JSONMethodCodec` делегирует кодирование значений полезной нагрузки (payload) в `JSONMessageCodec`.  
	
`Каналы событий` — это специализированные каналы платформы, предназначенные для использования в случае представления событий платформы Flutter в виде потока Dart. Работает как обычный `Stream`

[Подробнее](https://habr.com/ru/post/666272/)
	
---
<!-- TOC --><a name="--10"></a>
### Режимы сборки
- `Debug` (`JIT`) для разработки
- `Release` (`AOT`) для публикации приложения
- `Profile` (`AOT`) для анализа производительности 
	
---
<!-- TOC --><a name="package-plugin"></a>
### Package и Plugin
- `Package` написан только на dart
- `Plugin` использует dart и специфичный код для платформы

---
<!-- TOC --><a name="ffi-plugin"></a>
### FFI Plugin
- `FFI Plugin` - плагин, в котором для написания специфичных платформенных частей используется [Dart FFI](https://dart.dev/guides/libraries/c-interop). Позволяет запустить код на C / C++

---
<!-- TOC --><a name="--11"></a>
### Этапы анимации
- `Ticker` просит `SchedulerBinding` зарегистрировать обратный вызов и сообщить `Flutter Engine`, что надо разбудить его, когда появится новый обратный вызов. 
- Когда `Flutter Engine` готов, он вызывает `SchedulerBinding` через запрос `onBeginFrame`. 
- `SchedulerBinding` обращается к списку обратных вызовов `ticker` и выполняет каждый из них.
- Каждый `tick` перехватывается "заинтересованным" контроллером для его обработки. 
- Если анимация завершена, то `ticker` "отключён", иначе `ticker` запрашивает `SchedulerBinding` для планирования нового обратного вызова. 
- ...
	
---
<!-- TOC --><a name="--12"></a>
### Виды анимаций
- `Tween animation`. Начало, конец, время, скорость заранее определенно  
- `Physics-based animation`. Имитируют реальное поведение

---
<!-- TOC --><a name="-tween"></a>
### Что такое Tween
`Tween` - это объект, который описывает между какими значениями анимируется виджет и отвечает за вычисление текущего значения анимации
	
---
<!-- TOC --><a name="tween-"></a>
### Tween анимации
- `Implicit Animations` - это набор `Implicitly Animated Widgets`, которые анимируются самостоятельно при их перестройке с новыми аргументами. (`AnimatedAlign`, `AnimatedContainer`, `AnimatedPadding` и т.д.)
- `Explicit Animations` -  это набор элементов управления анимационными эффектами. Предоставляют куда больше контроля над анимацией, чем `Implicit Animations`. Для использования необходимо подмешать к стейту вашего виджета `SingleTickerProviderStateMixin` / `TickerProviderStateMixin`, создать `AnimationController` и зависящие от него `Animation`, передать анимацию в `Transition Widget` (`AlignTransition`, `DecoratedBoxTransition`, `SizeTransition` и т.д.) 
`SingleTickerProviderStateMixin` / `TickerProviderStateMixin` создает `Ticker`  
`Ticker` вызывает callback на каждый фрейм анимации  
`AnimationController` пределяет все фреймы анимации - управляет анимацией (forward, reverse, repeat, stop, reset и т.д.)  
`Animation` отдает текущее значение анимации, а также позволяет подписаться на обновления значения/статуса анимации  	

---
<!-- TOC --><a name="--13"></a>
### Построение кадра
1. Некоторые внешние события приводят к необходимости обновления отображения. 
2. `Schedule Frame` отправляется к `Flutter Engine` 
3. Когда `Flutter Engine` готов приступить к обновлению рендеринга, он создает `Begin Frame` запрос
4. Этот `Begin Frame` запрос перехватывается `Flutter Framework`, который выполняет задачи, связанные в основном с `Tickers` (например, анимацию)
5. Эти задачи могут повторно создать запрос для более поздней отрисовки (пример: анимация не закончила своё выполнение, и для завершения ей потребуется получить еще один `Begin Frame` на более позднем этапе)
6. Далее `Flutter Engine` отправляет `Draw Frame`, который перехватывается `Flutter Framework`, который будет искать любые задачи, связанные с обновлением макета с точки зрения структуры и размера
7. После того, как все эти задачи выполнены, он переходит к задачам, связанным с обновлением макета с точки зрения отрисовки
8. Если на экране есть что-то, что нужно нарисовать, то новая сцена для визуализации отправляется в `Flutter Engine`, который обновит экран
9. Затем `Flutter Framework` выполняет все задачи, которые будут выполняться после завершения рендеринга (`PostFrame callbacks`), и любые другие последующие задачи, не связанные с рендерингом
10. …

---
<!-- TOC --><a name="--14"></a>
### Расчёт макета
- Ограничения спускаются вниз по дереву, от родителей к детям.
- Размеры идут вверх по дереву от детей к родителям.
- Родители устанавливают положение детей.  

---
<!-- TOC --><a name="buildowner"></a>
### BuildOwner
`BuildOwner` — менеджер сборки и обновления дерева элементов. Он активно участвует в двух фазах — сборки и завершения сборки. Поскольку `BuildOwner` управляет процессом сборки дерева, в нем хранятся списки неактивных элементов и списки элементов, нуждающихся в обновлении.  
Методы:
- `scheduleBuildFor` даёт возможность пометить элемент как нуждающийся в обновлении.
- `lockState` защищает элемент от неправильного использования, утечек памяти и пометки на обновления в процессе уничтожения.
- `buildScope` осуществляет пересборку дерева. Работает с элементами, которые помечены как нуждающиеся в обновлении.
- `finalizeTree` завершает построение дерева. Удаляет неиспользуемые элементы и осуществляет дополнительные проверки в режиме отладки — в том числе на дублирование глобальных ключей.
- `reassemble` обеспечивает работу механизма `HotReload`. Этот механизм позволяет не пересобирать проект при изменениях, а отправлять новую версию кода на `DartVM` и инициировать обновление дерева.
	
---
<!-- TOC --><a name="pipelineowner"></a>
### PipelineOwner
`PipelineOwner` — менеджер сборки, который занимается работой с деревом отображения.


---
<!-- TOC --><a name="task-runners"></a>
### Task Runners
![image](https://user-images.githubusercontent.com/80569772/211004726-1eeef86f-cebf-41de-8bb3-a8485257565f.png)  
- `Platform Task Runner`: Основной поток платформы. Здесь выполняется код плагинов. Для получения дополнительной информации см. документацию по UIKit для iOS или документацию по MainThread для Android. Этот поток не отображается в наложении производительности.
- `UI Task Runner`: Поток UI выполняет код Dart в виртуальной машине Dart VM. Этот поток включает в себя код, написанный вами, и код, выполняемый фреймворком Flutter от имени вашего приложения. Когда ваше приложение создает и отображает сцену, поток UI создает дерево слоев - легкий объект, содержащий команды рисования, не зависящие от устройства, и отправляет дерево слоев в растровый поток для отображения на устройстве. Не блокируйте этот поток! Показан в нижней строке оверлея производительности.
- `Raster Task Runner`: Растровый поток получает дерево слоев и отображает его, обращаясь к GPU (графическому процессору). Вы не можете напрямую обращаться к растровому потоку или его данным, но если этот поток работает медленно, то это результат того, что вы сделали в коде Dart. В этом потоке работают графические библиотеки Skia и Impeller. Они показаны в верхней строке оверлея производительности. Ранее этот поток был известен как "GPU-поток", поскольку он выполняет растеризацию для GPU. Однако он выполняется на центральном процессоре. Мы переименовали его в "растровый поток", поскольку многие разработчики ошибочно (но вполне обоснованно) полагали, что этот поток работает на GPU.
- `IO Task Runner`: Выполняет дорогостоящие задачи (в основном ввод-вывод), которые в противном случае блокировали бы работу потоков пользовательского интерфейса или растровых потоков. Этот поток не отображается в оверлее производительности.
	
[Подробнее](https://www.programmersought.com/article/81813680395/), [Подробнее 2](https://medium.com/flutter-community/the-layer-cake-widgets-elements-renderobjects-7644c3142401)

<!-- TOC --><a name="-5"></a>
## Архитектура
<!-- TOC --><a name="-6"></a>
### Архитектура
Архитектура - это набор решений по организации программы. Таких, как деление программы на слои, построение связей между ними, управление состоянием, связь с UI. Хорошая архитектура делает слои в приложении слабо связанными, что упрощает внесение изменений, повышает тестируемость кода, упрощает систему  

---
<!-- TOC --><a name="--15"></a>
### Чистая архитектура
Чистая архитектура - архитектура, которая следует `SOLID` и делится на три независимых слоя:  
- `Data (datasources, models, repositories)` получение данных извне
- `Domain (entities, repositories interfaces, usecases)` бизнес правила
- `Presentation (bloc, pages, widgets)` отображение
	
[Пример](https://github.com/ResoCoder/flutter-tdd-clean-architecture-course)		

---
<!-- TOC --><a name="--16"></a>
### Управление состоянием

**Vanilla**   
	
`Плюсы`  
- Низкий порог вхождения.
- Не требуются сторонние библиотеки.  

`Минусы`  
- При изменении состояния виджета дерево виджетов каждый раз целиком пересоздается.
- Нарушает принцип единственной ответственности. Виджет отвечает не только за создание UI, но и за загрузку данных, бизнес-логику и управление состоянием.
- Решения о том как именно отображать текущее состояние принимаются прямо в UI коде. Если состояние станет более сложным, то читаемость кода сильно понизится.  

`Использование:`
- Widget State 

**BLoC**  
	
`Плюсы`  
- Четкое разделение ответственности
- Предсказуемые преобразования Event to State
- Реактивность. Нет необходимости в вызове дополнительных методов
	
`Минусы`
- Обязательность состояния в Bloc-е 
- Частые изменения библиотеки
- Зависимость от сторонней библиотеки

`Использование:`
- Widget State
- App State

**Redux**
	
`Плюсы`  
- Единое состояние
- Все экшены доступны всем  

`Минусы`  
- Единое состояние
- Зависимость от сторонней библиотеки
- Большое количество boilerplate кода
- Все экшены доступны всем  

`Использование:`
- Widget State
- App State

**Provider**
	
`Плюсы`  
- Скоупы на поддеревья
- Flutter ориентирован
- Нет статики
- Готовые провайдеры

`Минусы`  
- Завязка на фреймворк
- Только 1 провайдер одного типа
- Зависимость от сторонней библиотеки

`Использование:`
- App State
- Частично DI

**Riverpod**  
	
`Плюсы:`  
- Скоупы на поддеревья
- Flutter ориентирован
- Нет статики
- Готовые провайдеры

`Минусы:`
- Зависимость от сторонней библиотеки
- Циклические зависимости падают в runtime-е

`Использование:`
- Widget State
- App State
- DI

---
<!-- TOC --><a name="dependency-injection"></a>
### Dependency Injection  
`Dependency injection (DI)` - это механизм, который позволяет сделать взаимодействующие в приложении объекты слабосвязанными с помощью интерфейсов. Это делает всю систему более гибкой, более адаптируемой и расширяемой

---
<!-- TOC --><a name="--17"></a>
### Архитектурные патерны  
![](https://fuzeservers.ru/wp-content/uploads/2/6/8/268a107e69309f0529c18aae72769bdb.png)
**MVVM** 

`Части:`
- `Model` содержит в себе всю логику приложения, она хранит и обрабатывает данные, при этом не взаимодействуя с пользователем напрямую
- `View` отображает данные, которые ему передали
- `ViewModel` связывает модель и представление (передаёт данные между ними)

`Использование:`
-   Используется в ситуации, когда возможно связывание данных без необходимости ввода специальных интерфейсов представления (т.е. отсутствует необходимость реализовывать IView);
-   Частым примером является технология WPF.

[Подробнее](https://habr.com/ru/post/427327/)  [Пример](https://github.com/jitsm555/Flutter-MVVM)

**MVC** 

`Части:`
- `Model` содержит в себе всю логику приложения, она хранит и обрабатывает данные, при этом не взаимодействуя с пользователем напрямую
- `View` отображает данные, которые ему передали
- `Controller` перехватывает событие извне и в соответствии с заложенной в него логикой, реагирует на это событие изменяя Mодель, посредством вызова соответствующего метода. После изменения Модель использует событие о том что она изменилась, и все подписанные на это события Представления, получив его, обращаются к Модели за обновленными данными, после чего их и отображают 

`Использование:`
-   Используется в ситуации, когда невозможно связывание данных (нельзя использовать Binding);

[Пример](https://github.com/flutter-devs/Flutter_MVC)

**MVP**

`Части:`
- `Model` содержит в себе всю логику приложения, она хранит и обрабатывает данные, при этом не взаимодействуя с пользователем напрямую
- `View` отображает данные, которые ему передали
- `Presenter` подписывается на события представления, по запросу изменяет модель, обновляет представление

`Использование:`
-   Используется в ситуации, когда связь между представление и другими частями приложения невозможна (и Вы не можете использовать MVVM или MVP);

---
<!-- TOC --><a name="--18"></a>
### Способы осуществления навигации
**Navigator**
- Идёт из коробки  

**Go Router**  
- Парсинг пути и параметров запроса (например, "user/:id")
- Поддержка deep-links
- Поддержка перенаправления - вы можете перенаправить пользователя на другой URL-адрес в зависимости от состояния приложения
- Именованные роуты

**Auto Route**  
- Парсинг пути и параметров запроса (например, "user/:id")
- Поддержка deep-links
- Защищённые маршруты 
- Именованные роуты
- Разные варианты анимаций

---
<!-- TOC --><a name="--19"></a>
### Базы данных
**Нереляционные (NoSQL):**  
**Hive** 

`Плюсы:`
- Реализация на чистом Dart, без платформенного кода, за счёт чего одинаково работает на разных платформах
- Прост в использовании
- Быстрая запись / чтение
- Мало boilerplate кода
- Наличие кодогенерации
- Поддерживается на всех платформах
	
`Минусы:` 
- Связи между объектами нужно поддерживать вручную
- Ограничение по количеству адаптеров для объектов - 224
- Ограничение по количеству полей в адаптере - 255
- Плохо подходит для работы с большим объемом данных
- Выгружает всю бд в память
- Нельзя получить доступ к box-у, созданному в другом изоляте
- Наличие кодогенерации
- Нет миграций

`Использование:`
- Небольшой объём данных
- Необходимость в сохранении своих дата моделей

**Shared Preferences** 
	
`Плюсы:`
- Прост в использовании 
- Синхронное чтение из кэша в памяти
- Поддерживается на всех платформах

`Минусы:` 
- Разные реализации для Android/iOS и других платформ
- Обращение к платформенному коду
- Не гарантируется запись на диск после успешного выполнения метода
- Нельзя сохранять сложные объекты из коробки

`Использование:`
- Небольшой объём данных
- Необходимость в быстром внедрении решения
- Сохранение настроек приложения в виде примитивных данных

**Реляционные (SQL):**  
**SQFLite**
	
`Плюсы`
- Есть миграции
- Поддерживает связи между сущностями
- Не выгружает бд в оперативную память
- Возможность написания сложных запросов на SQL
	
`Минусы:` 
- Сложен в использовании
- Не поддерживается в Web, Linux, Windows
- Скорость работы ниже чем у NoSQL
- На разных OS и версиях могут быть разные версии SQLite

`Использование:`
- Большой объём данных
- Хранение сложно структурированных данных

**Drift**
- Есть миграции
- Поддерживает связи между сущностями
- Не выгружает бд в оперативную память
- Возможность написания сложных запросов на SQL
	
`Плюсы`
- Есть миграции
- Быстрый
- Поддерживается на всех платформах
	
`Минусы:` 
- Сложен в использовании
- Скорость работы ниже чем у NoSQL

`Использование:`
- Большой объём данных
- Хранение сложно структурированных данных

<!-- TOC --><a name="-7"></a>
## Тестирование

<!-- TOC --><a name="--20"></a>
### Виды тестов
- `Модульный тест` тестирует одну функцию, метод или класс. Его цель - проверить правильность работы определенной функции, метода или класса. Внешние зависимости для тестируемого модуля обычно передаются как параметр.
- `Виджет тест` тестирует один виджет. Цель такого теста — убедиться, что пользовательский интерфейс виджета выглядит и взаимодействует, как запланировано. Тестирование виджета происходит в тестовой среде, которая обеспечивает контекст жизненного цикла виджета. Также тестируемый виджет должен иметь возможность получать действия и события пользователя и отвечать на них . 
- `Интеграционный тест` тестирует все приложение или его большую часть. Цель интеграционного теста — убедиться, что все тестируемые виджеты и сервисы работают вместе, как ожидалось. Кроме того, вы можете использовать интеграционные тесты для проверки производительности вашего приложения. Как правило, интеграционный тест выполняется на реальном устройстве или эмуляторе.

---
<!-- TOC --><a name="tdd"></a>
### TDD
`TDD` — это методика разработки приложений, при которой сначала пишется тест, покрывающий желаемое изменение, а затем — код, который позволит пройти тест.
