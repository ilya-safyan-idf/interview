<!-- TOC --><a name="dart"></a>
# Dart

<!-- TOC --><a name="Типы-данных"></a>
## Типы данных
- `object?`
- `Iterable` => `List` + `Set` + `Map` + `Queue` + `LinkedList`+ `SplayTreeSet`
- `Num` => `double` + `int`
- `String`
- `bool`

***returned Iterable***  => `map()` + `where()` + `reduce() сокращает до одного` 

Проход по iterable :
```Dart
 Iterable<int> numbers = [1, 2, 3, 4, 5];
  Iterator<int> iterator = numbers.iterator;

  while (iterator.moveNext()) {
    int currentNumber = iterator.current;
    print(currentNumber);  // Выведет числа 1, 2, 3, 4, 5 по очереди
  }
```


--- ***Queue*** -  Коллекция, реализующая структуру данных очередь. (удобно добавлять элементы с начали и с конца)
`Queue<int> queue = Queue.from([1, 2, 3, 4, 5]);`
--- ***LinkedList***  - каждый элемент знает о следующем и предыдущем
--- ***SplayTreeSet*** O(log n) - повторный доступ к элементам делает быстрее. Каждый раз при вставке либо удалении происходит Splay - перетаскивание элемента ближе к корню двоичного дерева

---
<!-- TOC --><a name="final-const"></a>
## final и const и var
- `final` 
-- обозначает неизменяемое значение
-- вычисляется в runtime-е (к примеру результат выполнения другой функции)
-- при использовании  final в памяти выделяется новая область памяти, даже если значение объекта будет идентично.
-- значения не могут быть изменены после первого инита
- `const` 
-- вычисляется во время компиляции. 
-- новая область памяти не выделяется, а используется ссылка на уже существующий экземпляр

---
<!-- TOC --><a name="never"></a>
## Never
`Never` - это тип, означающий, что ни один тип не разрешен и `Never` сам по себе не может быть создан. Используется как возвращаемый тип при гарантированной ошибке.

---
<!-- TOC --><a name="-3"></a>
## Аннотации
`Аннотации`
-- дополнительную информацию к любому компоненту кода
-- любой класс может быть аннотацией, если в нем определен const конструктор.

---

<!-- TOC --><a name="future"></a>
## Future
`Future`
-- это обёртка над результатом выполнения асинхронной операции. 
-- выполняется Event Loop.

Состояния Future:
- Uncompleted - операция не завершена
- Completed with Result - операция завершена успешно
- Completed with Error - операция завершена с ошибкой

---
<!-- TOC --><a name="-future"></a>
## Конструкторы Future
- `Future(FutureOr<T> computation())`
-- создает объект future, который с помощью метода Timer.run запускает функцию computation асинхронно и возвращает ее результат.
- `FutureOr<T>`
-- указывает, что функция  должна возвращать либо объект Future<T> либо объект типа T.

- `Future.delayed(Duration duration, [FutureOr<T> func()])`
-- создает объект Future, который запускается после задержки, указанной через первый параметр Duration.
-- Второй необязательный параметр указывает на функцию, которая запускается после этой задержки.
- `Future.error(Object error, [StackTrace stackTrace])`
-- создает объект Future, который содержит информацию о возникшей ошибке.
- `Future.microtask(FutureOr<T> func())`
-- создает объект Future, который с помощью функции scheduleMicrotask запускает функцию асинхронно и возвращает ее результат.
- `Future.wait(FutureOr<T> computation())`
-- одновременно запускаем несколько асинхронных операций.
-- возвращает List
-- дожидается выполнения всех  future 
```Dart
body: FutureBuilder<List<FlashCardList>>(
    future: Future.wait([
        fetchFlashCardList(),
        fetchFlashCardListFromDB(),
    ])
```
- `Future.value()`
-- используется как заглушка

---
<!-- TOC --><a name="await-"></a>
## Await под капотом
-- ждет выполнения ассихронной операции
-- под капотом вызывает then у Future

---
<!-- TOC --><a name="stream"></a>
## Stream
`Stream` - это последовательность асинхронных событий. Stream сообщает вам, что есть событие и когда оно будет готово  
- `Single subscription` - это вид потока, при котором может быть только один подписчик. 
- `Broadcast` - это вид потока, при котором может быть много подписчиков. При этом Broadcast стримы отдают свои данные вне зависимости от того, подписан ли кто-нибудь на них или нет. Подписчики стрима получают события только с момента подписки, а не с момента старта жизни стрима
---
<!-- TOC --><a name="isolate"></a>
## Isolate
`Isolate` -  это легковесный процесс (поток исполнения), который выполняется параллельно с другими потоками и процессами в приложении. Каждый `Isolate` в Dart имеет свой собственный экземпляр виртуальной машины Dart, собственную память и управляется с помощью своего `Event Loop`.

--- 
<!-- TOC --><a name="-sync-async"></a>
## Генераторы (sync* / async*)  
`Генератор` это ключевое слово, которое позволяет создавать последовательность значений с помощью `yield`
- *sync** - это синхронный генератор. Возвращает `Iterable`
- *async** - это aсинхронный генератор. Возвращает `Stream`

```Dart
Iterable<void> febonachi(int n) sync* {
  int a = 0;
  int b = 1;

  while (a <= n) {
    yield a;
    int next = a + b;
    a = b;
    b = next;
  }
}

Stream<int> generateNumbers(int last) async* {
  for (int i = 1; i <= last; i++) {
    yield i; // Передаем каждое число в поток
    await Future.delayed(Duration(seconds: 1)); // Имитация задержки
  }
}
```

---

<!-- TOC --><a name="hashcode"></a>
## HashCode
`Хэш-код` 
-- геттер, у любого объекта (int get hashCode => )
-- возвращает `int`
-- используется для сравнения объектов 

---
<!-- TOC --><a name="extension"></a>
## Extension
`Extension` 
- это синтаксический сахар, который позволяет расширить существующий класс

--- 
<!-- TOC --><a name="mixin"></a>
## Mixin
`Миксин` - это механизм множественного наследования, который позволяет классам использовать функциональность других классов без явного наследования.

Миксины в Dart определяются ключевым словом `mixin`. Они могут содержать методы, поля и геттеры/сеттеры, но не могут иметь конструкторов. Вместо этого, миксины инициализируются автоматически, когда они применяются к классу. Для использования миксинов применяется оператор `with`    

Если у миксинов будет метод с одинаковым названием, то останется реализация, которая указана в последнем миксине. Так как миксины будут переопределять этот метод

---

<!-- TOC --><a name="late"></a>
## Late
`Late` - это ключевое слово в dart, которое позволяет объявить non-nullable переменную и при этом не установить для нее значение. Значение инициализируется только тогда, когда мы к нему обращаемся 

---
<!-- TOC --><a name="generics"></a>
## Generics

`Generics` - это параметризованные типы. Они позволяют программе уйти от жесткой привязки к определенным типам, определить функционал так, чтобы он мог использовать данные любых типов и обеспечить их безопасность. Так же обобщения снижают повторяемость кода, дают вам возможность предоставить единый интерфейс и реализацию для многих типов.

---
<!-- TOC --><a name="covariant"></a>
## Covariant
`Covariant` - означает 

```Dart
class Transport {
  void startEngine() {
    print("Engine started.");
  }
}

class Car extends Transport {
  @override
  void startEngine() {
    print("Car engine started.");
  }
}

class TransportHandler {
  void handle(Transport ts) {
    print("Handling vehicle.");
    ts.startEngine();
  }
}

class CarHandler extends VehicleHandler {
  @override
  void handle(covariant Car car) { // означает что только этот метод может быть передан
    print("Handling car.");
    car.startEngine();
  }
}
```

<!-- TOC --><a name="completer"></a>
## Completer
`Completer` 
-- класс из библиотеки dart:async
-- можем управлять (создавать) Future:
---- completer.complete('пример');
---- completer.completeError(Exception('No result provided'));
---- completer.future

```Dart

Future<String> delayedComputation(int timeout, {String? result}) {
  Completer<String> completer = Completer();

  Future.delayed(Duration(seconds: timeout), () {
    if (result != null) {
      completer.complete(result);
    } else {
      completer.completeError(Exception('No result provided'));
    }
  });
  return completer.future; 
}
```

--- 

<!-- TOC --><a name="compute"></a>

## Compute
`Compute` - это функция, которая создаёт изолят и запускает переданный код.

---

# Работа Dart

<!-- TOC --><a name="complilation-jit-aot"></a>
## Complilation  JIT AOT
- ` JIT (Just-In-Time compilation)`
-- блогодоря чему возможно делать hot reload и hot restart
- `AOT Compilation (Ahead-Of-Time Compilation)`
-- преобразование в машинный код
-- после чего компиляция не неужна.

+ `hot reload`
-- пересобирает только виджеты которые изменились
-- сохраняет состояния приложения 
-- крут для верстки

+ `hot restart`
-- перезапускает VM
-- 

<!-- TOC --><a name="dart-vm"></a>
## Dart VM
`Dart VM (Dart virtual machine)` -  среда выполнения Dart

Компоненты:
- `Среда исполнения`
-- среда в которой выполняется программа
- `Сборщик мусора`
- `Система отладка`
-- инструменты для поиска ошибок
-- это и есть debugger (можно делать точку остановки)
- `Профилировщик`
-- инструмент для анализа
- `Симулятор ARM архитектуры`
-- позволяет симулировать iphone android 
---

<!-- TOC --><a name="garbage-collector"></a>
## Garbage Collector
`Garbage Collector`
-- это алгоритм,
-- наблюдает за ссылками и очищает память

- **Сборщик молодого мусора**  
- **Сборщик старого мусора**  
---

<!-- TOC --><a name="--2"></a>
## Стек и куча
- `Стек` LIFO  — это область оперативной памяти.
-- имеет ограниченный размер
 -- хранятся временные данные (локальные переменны). 
 -- объем памяти, ограничен. Стек работает в порядке LIFO

 ```Dart
 void myFunction() {
    int localVariable = 5; // Переменная хранится в стеке

  // при вызове localVariable помещается в Стек
  // при выходе удаляется
}
 ```
- `Куча`
-- с кучей взаимодействует garbage collector
 -- Размер кучи задаётся при запуске приложения.
 -- ограничений по памяти нету (только физически)
 -- Выделение памяти медленнее, чем в стеке.
 -- хранятся все константные переменные,
 -- хранятся все объекты и коллекции

---

<!-- TOC --><a name="event-loop"></a>
## Event Loop
`Event Loop` - вечный цикл, выполняющий все поступающие в изолят задачи.
В нём есть две FIFO очереди задач:

`Очередь MicroTask`  
Используется для очень коротких действий, которые должны быть выполнены асинхронно, сразу после завершения какой-либо инструкции перед тем, как передать управление обратно Event Loop. Очередь MicroTask имеет приоритет перед очередью Event 
 
`Очередь Event`
Используется для планирования операций, которые получают результат от внешних событий (операции ввода/вывода, жесты, рисование, таймеры, потоки)

---

<!-- TOC --><a name="-2"></a>
## Зоны
Зона - это механизм, который позволяет управлять и обрабатывать ошибки и другие события, происходящие в определенных областях кода.

1. Защита вашего приложения от завершения из-за необработанного исключения
2. Ассоциирование данных, известных как `zone-local values`, с отдельными зонами
3. Переопределение ограниченного набора методов, таких как print() и scheduleMicrotask(), внутри части или всего кода
4. Выполнение операции каждый раз, когда код входит или выходит из зоны. Эти операции могут включать в себя запуск или остановку таймера или сохранение stacktrace-а

---
<!-- TOC --><a name="--4"></a>
## Типы ошибок
`Exception` - это общий класс для исключений, 
  -- о возникают из-за ошибок в программе
  -- их можно обработать

- FormatException
- HttpException
- TimeoutException

`Error` - это класс для ошибок, 
-- ошибки не могут быть восстановлены
-- они указывают на серьезные проблем

- AsyncError
- TypeError

---


<!-- TOC --><a name="ffi-plugin"></a>
## FFI Plugin
- `FFI Plugin (Foreign Function Interface)`
-- возможность языка Dart вызывать C/C++ код.
-- вызов нативных функций для работы с оборудованием (камера)

```Dart
import 'dart:ffi';
import 'dart:io';

typedef add_func = Int32 Function(Int32, Int32);
typedef Add = int Function(int, int);

void main() {
  final dylib = DynamicLibrary.open("example_library.so");
```
---
<!-- TOC --><a name="--5"></a>
## Правила именования
- Переменные и константы - `lowerCamelCase`
- Классы, миксины, enum-ы - `UpperCamelCase`
- Файлы - `snake_case`

---


